var tipuesearch = {"pages":[{"title":" Numerical Methods ","text":"Numerical Methods Developer Info Manuel Pena","tags":"home","loc":"index.html"},{"title":"test_utilities.f08 – Numerical Methods","text":"This file depends on sourcefile~~test_utilities.f08~~EfferentGraph sourcefile~test_utilities.f08 test_utilities.f08 sourcefile~utilities.f08 utilities.f08 sourcefile~test_utilities.f08->sourcefile~utilities.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_utilities Source Code test_utilities.f08 Source Code program test_utilities use utilities implicit none integer , parameter :: M = 3 , N = 4 real :: A ( M , N ) call random_number ( A ) A = A - 0.5 print * , \"A =\" call print_matrix ( A ) end program","tags":"","loc":"sourcefile/test_utilities.f08.html"},{"title":"test_non_linear_solvers.f08 – Numerical Methods","text":"This file depends on sourcefile~~test_non_linear_solvers.f08~~EfferentGraph sourcefile~test_non_linear_solvers.f08 test_non_linear_solvers.f08 sourcefile~non_linear_solvers.f08 non_linear_solvers.f08 sourcefile~test_non_linear_solvers.f08->sourcefile~non_linear_solvers.f08 sourcefile~linear_solvers.f08 linear_solvers.f08 sourcefile~non_linear_solvers.f08->sourcefile~linear_solvers.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_non_linear_solvers Source Code test_non_linear_solvers.f08 Source Code program test_non_linear_solvers !! program to test the non_linear_solvers module use non_linear_solvers implicit none print * , Bisection ( f , 0. , 1.234 , 0.001 ) print * , Newton ( f , df , 0. , 0.001 , 0.001 , 1000 ) print * , Secant ( f ,[ 0. , 0.1 ], 0.001 , 0.001 , 1000 ) print * , VectorNewton ( f_vec , J ,[ 0.5 , 0.5 ], 0.001 , 0.001 , 1000 ) contains function f ( x ) result ( y ) real , intent ( in ) :: x real :: y y = exp ( x ) - exp ( 1. ) end function function df ( x ) result ( y ) real , intent ( in ) :: x real :: y y = exp ( x ) end function function f_vec ( x ) result ( y ) real , intent ( in ) :: x (:) real :: y ( size ( x )) y ( 1 ) = exp ( x ( 1 )) - exp ( 1. ) y ( 2 ) = x ( 1 ) * cos ( x ( 2 )) end function function J ( x ) result ( y ) real , intent ( in ) :: x (:) real :: y ( size ( x ), size ( x )) y ( 1 ,:) = [ exp ( x ( 1 )), 0. ] y ( 2 ,:) = [ cos ( x ( 2 )), - x ( 1 ) * sin ( x ( 2 )) ] end function end program","tags":"","loc":"sourcefile/test_non_linear_solvers.f08.html"},{"title":"test_linear_solvers.f08 – Numerical Methods","text":"This file depends on sourcefile~~test_linear_solvers.f08~~EfferentGraph sourcefile~test_linear_solvers.f08 test_linear_solvers.f08 sourcefile~linear_solvers.f08 linear_solvers.f08 sourcefile~test_linear_solvers.f08->sourcefile~linear_solvers.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test Source Code test_linear_solvers.f08 Source Code program test !! Program to show the usage of the *linear_solvers* module use linear_solvers implicit none integer , parameter :: N = 500 real :: ti , tf real :: A ( N , N ), b ( N ), x_G ( N ), x_LU ( N ), x_J ( N ), x_GS ( N ), x_0 ( N ) integer :: i , u , Nmax b = 0 b ( N ) = - 1. A = 0. do i = 1 , N - 1 A ( i , i + 1 ) = 1. A ( i , i ) = - 2. A ( i + 1 , i ) = 1. end do A ( N , N ) = - 2 call CPU_TIME ( ti ) x_G = gauss_solve ( A , b ) call CPU_TIME ( tf ) print * , 'Gauss' print '(3(A,1x,f9.6,A))' , 'x =' , x_G ( 1 ), NEW_LINE ( 'a' ), 'y =' , x_G ( 2 ), NEW_LINE ( 'a' ), 'z =' , x_G ( 3 ), NEW_LINE ( 'a' ) print '(A,1x,I6,1x,A)' , 'in' , floor (( tf - ti ) * 1E3 ), 'miliseconds' call CPU_TIME ( ti ) x_LU = solve ( A , b ) call CPU_TIME ( tf ) print * , 'LU' print '(3(A,1x,f9.6,A))' , 'x =' , x_LU ( 1 ), NEW_LINE ( 'a' ), 'y =' , x_LU ( 2 ), NEW_LINE ( 'a' ), 'z =' , x_LU ( 3 ), NEW_LINE ( 'a' ) print '(A,1x,I6,1x,A)' , 'in' , floor (( tf - ti ) * 1E3 ), 'miliseconds' Nmax = 100000 ! x_0 = 0.5 x_0 ( 1 : N / 2 ) = 0.25 x_0 ( N / 2 + 1 : N ) = 0.75 call CPU_TIME ( ti ) x_J = Jacobi ( A , b , x_0 , Nmax , 0.0001 ) call CPU_TIME ( tf ) print * , 'Jacobi' print '(3(A,1x,f9.6,A))' , 'x =' , x_J ( 1 ), NEW_LINE ( 'a' ), 'y =' , x_J ( 2 ), NEW_LINE ( 'a' ), 'z =' , x_J ( 3 ), NEW_LINE ( 'a' ) print '(A,1x,I6,1x,A)' , 'in' , floor (( tf - ti ) * 1E3 ), 'miliseconds' call CPU_TIME ( ti ) x_GS = GaussSeidel ( A , b , x_0 , Nmax , 0.0001 ) call CPU_TIME ( tf ) print * , 'Gauss-Seidel' print '(3(A,1x,f9.6,A))' , 'x =' , x_GS ( 1 ), NEW_LINE ( 'a' ), 'y =' , x_GS ( 2 ), NEW_LINE ( 'a' ), 'z =' , x_GS ( 3 ), NEW_LINE ( 'a' ) print '(A,1x,I6,1x,A)' , 'in' , floor (( tf - ti ) * 1E3 ), 'miliseconds' open ( file = 'test.dat' , newunit = u , action = 'write' , status = 'unknown' ) do i = 1 , N write ( u , * ) x_G ( i ), x_LU ( i ), x_J ( i ), x_GS ( i ) end do close ( u ) end program","tags":"","loc":"sourcefile/test_linear_solvers.f08.html"},{"title":"linear_solvers.f08 – Numerical Methods","text":"Files dependent on this one sourcefile~~linear_solvers.f08~~AfferentGraph sourcefile~linear_solvers.f08 linear_solvers.f08 sourcefile~eigen.f08 eigen.f08 sourcefile~eigen.f08->sourcefile~linear_solvers.f08 sourcefile~non_linear_solvers.f08 non_linear_solvers.f08 sourcefile~non_linear_solvers.f08->sourcefile~linear_solvers.f08 sourcefile~test_linear_solvers.f08 test_linear_solvers.f08 sourcefile~test_linear_solvers.f08->sourcefile~linear_solvers.f08 sourcefile~test_eigen.f08 test_eigen.f08 sourcefile~test_eigen.f08->sourcefile~eigen.f08 sourcefile~test_non_linear_solvers.f08 test_non_linear_solvers.f08 sourcefile~test_non_linear_solvers.f08->sourcefile~non_linear_solvers.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules linear_solvers Source Code linear_solvers.f08 Source Code module linear_solvers !! Module for computing solutions to linear systems of the form: !! \\mathbf{A}\\mathbf{x}=\\mathbf{b} implicit none contains function solve_U ( U , b ) result ( x ) !! Computes the solution of an upper triangular system: !!  \\mathbf{U}\\mathbf{x} = \\mathbf{b} real , intent ( in ) :: U (:,:) !! Upper triangular matrix real , intent ( in ) :: b (:) !! Right hand side vector real :: x ( size ( U , 2 )) !! Solution vector **x** integer :: i , N N = size ( U , 2 ) x ( N ) = b ( N ) / U ( N , N ) do i = N - 1 , 1 , - 1 x ( i ) = ( b ( i ) - dot_product ( U ( i , i + 1 : N ), x ( i + 1 : N ))) / U ( i , i ) end do end function function solve_L ( L , b ) result ( x ) !! Computes the solution of a lower triangular system: !!  \\mathbf{L}\\mathbf{x} = \\mathbf{b} real , intent ( in ) :: L (:,:) !! Lower triangular matrix real , intent ( in ) :: b (:) !! Right hand side vector real :: x ( size ( L , 2 )) !! Solution vector **x** integer :: i , N N = size ( L , 2 ) x ( 1 ) = b ( 1 ) / L ( 1 , 1 ) do i = 2 , N x ( i ) = ( b ( i ) - dot_product ( L ( i , 1 : i - 1 ), x ( 1 : i - 1 ))) / L ( i , i ) end do end function subroutine make_U ( M ) !! Takes the extended matrix M = (A|b) !! and makes it upper triangular. real , intent ( inout ) :: M (:,:) !! Extended matrix (A|b) integer :: N , i , j , imax real :: Q real :: temp ( size ( M , 2 )) N = size ( M , 1 ) do j = 1 , N - 1 ! row swapping for stability imax = MAXLOC ( abs ( M ( j : N , j )), 1 ) + ( j - 1 ) temp = M ( j ,:) M ( j ,:) = M ( imax ,:) M ( imax ,:) = temp ! triangularization of column j do i = j + 1 , N Q = M ( i , j ) / M ( j , j ) M ( i ,:) = M ( i ,:) - Q * M ( j ,:) end do end do end subroutine function gauss_solve ( A , b ) result ( x ) !! Computes the solution of the system: !!  \\mathbf{A}\\mathbf{x}=\\mathbf{b} !! where **A** is a non-singular matrix. real , intent ( in ) :: A (:,:) !! Non-singular matrix real , intent ( in ) :: b (:) !! Right hand side vector real :: x ( size ( A , 2 )) !! Solution vector **x** real :: M ( size ( A , 1 ), size ( A , 2 ) + 1 ) integer :: N N = size ( A , 2 ) M (:, 1 : N ) = A M (:, N + 1 ) = b call make_U ( M ) x = solve_U ( M (:, 1 : N ), M (:, N + 1 )) end function subroutine factor_LU ( A , L , U ) !! Computes de LU factorization of a non-singular matrix **A** !! \\mathbf{A}=\\mathbf{L}\\mathbf{U} real , intent ( in ) :: A (:,:) !! Non-singular matrix real , intent ( out ) :: L ( size ( A , 1 ), size ( A , 2 )) !! Lower triangular matrix real , intent ( out ) :: U ( size ( A , 1 ), size ( A , 2 )) !! Upper triangular matrix integer :: N , i , j , k N = size ( A , 2 ) L = 0 U = 0 do k = 1 , N do j = k , N U ( k , j ) = A ( k , j ) - dot_product ( L ( k , 1 : k - 1 ), U ( 1 : k - 1 , j )) end do L ( k , k ) = 1 do i = k + 1 , N L ( i , k ) = ( A ( i , k ) - dot_product ( L ( i , 1 : k - 1 ), U ( 1 : k - 1 , k ))) / U ( k , k ) end do end do end subroutine function solve_LU ( L , U , b ) result ( x ) !! Computes the solution to the system: !! \\mathbf{L}\\mathbf{U}\\mathbf{x}=\\mathbf{b} !! where **L** and **U** are the matrices obtained from !! a LU factorization. real , intent ( in ) :: L (:,:) !! Lower triangular matrix real , intent ( in ) :: U (:,:) !! Upper triangular matrix real , intent ( in ) :: b (:) !! Right hand side vector real :: x ( size ( b )) !! Solution vector **x** x = solve_U ( U , solve_L ( L , b )) end function function solve ( A , b ) result ( x ) !! Computes the solution to the system: !! \\mathbf{A}\\mathbf{x}=\\mathbf{b} !! using LU factorization. real , intent ( in ) :: A (:,:) !! Non-singular matrix real , intent ( in ) :: b (:) !! Right hand side vector real :: x ( size ( b )) !! Solution vector **x** real :: L ( size ( A , 1 ), size ( A , 2 )), U ( size ( A , 1 ), size ( A , 2 )), Ap ( size ( A , 1 ), size ( A , 2 )) call factor_LU ( A , L , U ) x = solve_LU ( L , U , b ) end function function Jacobi ( A , b , x_0 , maxIter , err_x ) result ( x ) !! Computes the solution to the system !! \\mathbf{A}\\mathbf{x}=\\mathbf{b} !! using the Jacobi iterative method. real , intent ( in ) :: A (:,:) !! Non-singular matrix real , intent ( in ) :: b (:) !! Right hand side vector real , intent ( in ) :: x_0 (:) !! Initial approximation for the iteration integer , intent ( in ) :: maxIter !! Maximum number of iterations real , intent ( in ) :: err_x !! Precision for the stop criterion real :: x ( size ( A , 2 )) !! Solution vector **x** integer :: i , N real :: x_old ( size ( A , 2 )), L ( size ( A , 1 ), size ( A , 2 )), U ( size ( A , 1 ), size ( A , 2 )), D_inv ( size ( A , 2 )) N = size ( A , 2 ) L = 0 U = 0 do i = 1 , N L ( i , 1 : i - 1 ) = A ( i , 1 : i - 1 ) D_inv ( i ) = 1. / A ( i , i ) U ( i , i + 1 : N ) = A ( i , i + 1 : N ) end do x_old = x_0 do i = 1 , maxIter x = - D_inv * MATMUL ( L + U , x_old ) + D_inv * b if ( norm2 ( x - x_old ) / norm2 ( x ) < err_x ) exit x_old = x end do if ( i > maxIter ) print * , 'the maximum number of iteration was reached & & without obtaining convergence' end function function GaussSeidel ( A , b , x_0 , maxIter , err_x ) result ( x ) !! Computes the solution to the system !! \\mathbf{A}\\mathbf{x}=\\mathbf{b} !! using the Gauss-Seidel iterative method. real , intent ( in ) :: A (:,:) !! Non-singular matrix real , intent ( in ) :: b (:) !! Right hand side vector real , intent ( in ) :: x_0 (:) !! Initial approximation for the iteration integer , intent ( in ) :: maxIter !! Maximum number of iterations real , intent ( in ) :: err_x !! Precision for the stop criterion real :: x ( size ( A , 2 )) !! Solution vector **x** integer :: i , N real :: x_old ( size ( A , 2 )), LD ( size ( A , 1 ), size ( A , 2 )), U ( size ( A , 1 ), size ( A , 2 )) N = size ( A , 2 ) LD = 0 U = 0 do i = 1 , N LD ( i , 1 : i ) = A ( i , 1 : i ) U ( i , i + 1 : N ) = A ( i , i + 1 : N ) end do x_old = x_0 do i = 1 , maxIter x = solve_L ( LD , - MATMUL ( U , x_old ) + b ) if ( norm2 ( x - x_old ) / norm2 ( x ) < err_x ) exit x_old = x end do if ( i > maxIter ) print * , 'the maximum number of iteration was reached & & without obtaining convergence' end function end module","tags":"","loc":"sourcefile/linear_solvers.f08.html"},{"title":"test_eigen.f08 – Numerical Methods","text":"This file depends on sourcefile~~test_eigen.f08~~EfferentGraph sourcefile~test_eigen.f08 test_eigen.f08 sourcefile~eigen.f08 eigen.f08 sourcefile~test_eigen.f08->sourcefile~eigen.f08 sourcefile~linear_solvers.f08 linear_solvers.f08 sourcefile~eigen.f08->sourcefile~linear_solvers.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_eigenvectors Source Code test_eigen.f08 Source Code program test_eigenvectors !! Program to show the usage of the the *eigenvectors* module. use eigenvectors implicit none integer , parameter :: N = 3 integer :: i real :: A ( N , N ), v ( N ), lambda1 , lambda2 , lambda3 character (:), allocatable :: fmt fmt = '(F7.2)' A ( 1 ,:) = [ 1. , 0. , 0. ] A ( 2 ,:) = [ 0. , - 0.5 , 0. ] A ( 3 ,:) = [ 0. , 0. , - 4. ] call eigen_max ( A , v , lambda1 , maxIter = 1000 , err_v = 1.E-6 , v_0 = [ 1. , 1. , 1. ]) print * , \"biggest eigenvalue: \" write ( * , fmt = fmt ) lambda1 print * , \"associated eigenvector: \" do i = 1 , N write ( * , fmt = fmt ) v ( i ) end do call eigen_inv ( A , v , lambda1 , maxIter = 1000 , p = 0. , err_v = 1.E-6 , v_0 = [ 1. , 1. , 1. ]) print * , \"smallest eigenvalue: \" write ( * , fmt = fmt ) lambda1 print * , \"associated eigenvector: \" do i = 1 , N write ( * , fmt = fmt ) v ( i ) end do end program","tags":"","loc":"sourcefile/test_eigen.f08.html"},{"title":"non_linear_solvers.f08 – Numerical Methods","text":"This file depends on sourcefile~~non_linear_solvers.f08~~EfferentGraph sourcefile~non_linear_solvers.f08 non_linear_solvers.f08 sourcefile~linear_solvers.f08 linear_solvers.f08 sourcefile~non_linear_solvers.f08->sourcefile~linear_solvers.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~non_linear_solvers.f08~~AfferentGraph sourcefile~non_linear_solvers.f08 non_linear_solvers.f08 sourcefile~test_non_linear_solvers.f08 test_non_linear_solvers.f08 sourcefile~test_non_linear_solvers.f08->sourcefile~non_linear_solvers.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules non_linear_solvers Source Code non_linear_solvers.f08 Source Code module non_linear_solvers !! Module for solving non-linear equations of the form: !!  \\mathbf{f}\\left(\\mathbf{x}\\right)=\\mathbf{0}  !! There are specific functions for the scalar case. use linear_solvers , only : solve implicit none contains function Bisection ( f , a , b , err_x ) result ( x ) !! Solves the scalar non-linear equation: !!  f(x)=0  !! using the bisection method on the interval [a,b] interface function f ( x ) result ( y ) !! function defining the non-linear equation real , intent ( in ) :: x !! independent variable real :: y !! dependent variable end function end interface real , intent ( in ) :: a !! left boundary of the interval real , intent ( in ) :: b !! right boundary of the interval real , intent ( in ) :: err_x !! admisible error in the solution, that is: !!  x_\\mathrm{true} = x \\pm \\frac{\\epsilon_{x}}{2}  real :: x !! numerical aproximation to the solution integer :: N , i real :: x_l , x_r if ( f ( a ) * f ( b ) >= 0 ) error stop \"f(a) and f(b) must have different signs\" if ( a > b ) then error stop \"a cannot be greater than b\" else if ( a == b ) then x = a return else N = ceiling ( log (( b - a ) / err_x ) / log ( 2. )) end if x_l = a x_r = b do i = 1 , N x = ( x_l + x_r ) / 2 if ( f ( x ) == 0 ) then exit else if ( f ( x ) * f ( x_l ) > 0 ) then x_l = x else x_r = x end if end do end function function Newton ( f , df , x0 , err_x , err_f , max_iter ) result ( x ) !! Solves the scalar non-linear equation: !!  f(x) = 0  !! using Newton's method. interface function f ( x ) result ( y ) !! function defining the non-linear equation real , intent ( in ) :: x !! independent variable real :: y !! dependent variable end function function df ( x ) result ( y ) !! derivative of function f real , intent ( in ) :: x !! independent variable real :: y !! dependent variable end function end interface real , intent ( in ) :: x0 !! initial aproximation to the solution real , intent ( in ) :: err_x !! admisible error in the solution real , intent ( in ) :: err_f !! admisible error in the equation integer , intent ( in ) :: max_iter !! maximum number of iterations real :: x !! numerical aproximation to the solution integer :: i real :: x_old x_old = x0 do i = 1 , max_iter x = x_old - f ( x_old ) / df ( x_old ) if ( ( abs ( f ( x )) < err_f ) . or . ( abs ( x - x_old ) < err_x ) ) exit x_old = x end do if ( i > max_iter ) print * , \"maximum number of iterations reached without convergence\" end function function Secant ( f , x0 , err_x , err_f , max_iter ) result ( x ) !! Solves the scalar non-linear equation: !!  f(x) = 0  !! using the secant method. interface function f ( x ) result ( y ) !! function defining the non-linear equation real , intent ( in ) :: x !! independent variable real :: y !! dependent variable end function end interface real , intent ( in ) :: x0 ( 2 ) !! array containing the first and second aproximations to the solution real , intent ( in ) :: err_x !! admisible error in the solution real , intent ( in ) :: err_f !! admisible error in the equation integer , intent ( in ) :: max_iter !! maximum number of iterations real :: x !! numerical aproximation to the solution integer :: i real :: x_old ( 2 ) x_old = x0 do i = 1 , max_iter x = x_old ( 2 ) - f ( x_old ( 2 )) * ( x_old ( 2 ) - x_old ( 1 )) / ( f ( x_old ( 2 )) - f ( x_old ( 1 ))) if ( ( abs ( f ( x )) < err_f ) . or . ( abs ( x - x_old ( 2 )) < err_x ) ) exit x_old = [ x_old ( 2 ), x ] end do if ( i > max_iter ) print * , \"maximum number of iterations reached without convergence\" end function function VectorNewton ( f , J , x0 , err_x , err_f , max_iter ) result ( x ) !! Solves the vector non-linear equation: !!  f(x) = 0  !! using Newton's method. interface function f ( x ) result ( y ) !! function defining the non-linear equation real , intent ( in ) :: x (:) !! independent variable real :: y ( size ( x )) !! dependent variable end function function J ( x ) result ( y ) !! jacobian of function f real , intent ( in ) :: x (:) !! independent variable real :: y ( size ( x ), size ( x )) !! dependent variable end function end interface real , intent ( in ) :: x0 (:) !! initial aproximation to the solution: (x_0,y_0) real , intent ( in ) :: err_x !! admisible error in the solution real , intent ( in ) :: err_f !! admisible error in the equation integer , intent ( in ) :: max_iter !! maximum number of iterations real :: x ( size ( x0 )) !! numerical aproximation to the solution integer :: i real :: x_old ( size ( x0 )) x_old = x0 print * , J ( x_old ) do i = 1 , max_iter x = x_old - solve ( J ( x_old ), f ( x_old )) if ( ( norm2 ( f ( x )) < err_f ) . or . ( norm2 ( x - x_old ) < err_x ) ) exit x_old = x end do if ( i > max_iter ) print * , \"maximum number of iterations reached without convergence\" end function end module","tags":"","loc":"sourcefile/non_linear_solvers.f08.html"},{"title":"utilities.f08 – Numerical Methods","text":"Files dependent on this one sourcefile~~utilities.f08~~AfferentGraph sourcefile~utilities.f08 utilities.f08 sourcefile~test_utilities.f08 test_utilities.f08 sourcefile~test_utilities.f08->sourcefile~utilities.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules utilities Source Code utilities.f08 Source Code module utilities !! module with utilities like printing a matrix, or some constants implicit none real :: pi = acos ( - 1. ) !! mathematical constant pi real :: e = exp ( 1. ) !! mathematical constante e contains subroutine print_matrix ( A ) !! Prints a real matrix in a tabular form !! (can be improved) real , intent ( in ) :: A (:,:) !! matriz to be displayed integer :: M , N , i M = size ( A , 1 ) N = size ( A , 2 ) do i = 1 , M print '(*(1x,G0,:,\",\"))' , A ( i ,:) end do end subroutine subroutine to_csv ( D , filename ) !! saves two-dimensional array **D** to csv !! file **filename** real , intent ( in ) :: D (:,:) !! array to be saved character ( len =* ), intent ( in ) :: filename !! path to the csv file integer :: i , N , u open ( file = filename , newunit = u , status = 'new' , action = 'write' ) N = size ( D , 1 ) do i = 1 , N write ( u , '(*(G0,:,\",\",1x))' ) D ( i ,:) end do close ( u ) end subroutine subroutine read_2_columns_csv ( filename , D ) !! Reads a two-column csv from file **filename** !! and stores it in **D** character ( len =* ), intent ( in ) :: filename !! path to the file real , intent ( inout ), allocatable :: D (:,:) !! array containing the two columns read integer :: i , N , u , IO_status open ( file = filename , newunit = u , status = 'old' ) N = 0 do read ( u , * , IOstat = IO_status ) if ( is_iostat_end ( IO_status ) ) exit N = N + 1 end do allocate ( D ( N , 2 )) rewind ( u ) do i = 1 , N read ( u , * ) D ( i , 1 ), D ( i , 2 ) end do close ( u ) end subroutine end module","tags":"","loc":"sourcefile/utilities.f08.html"},{"title":"test_integrals.f08 – Numerical Methods","text":"This file depends on sourcefile~~test_integrals.f08~~EfferentGraph sourcefile~test_integrals.f08 test_integrals.f08 sourcefile~integrals.f08 integrals.f08 sourcefile~test_integrals.f08->sourcefile~integrals.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_integrals Source Code test_integrals.f08 Source Code program test_integrals !! program to show the usage of the *integrals* module use integrals , only : trapz , quad implicit none real , parameter :: pi = acos ( - 1. ) real :: a , b , h , Int integer :: i a = 0. b = 2 * pi h = 0.001 Int = quad ( f , a , b , h , 'Trapezoidal' ) print * , \"Integral of sin(x) between 0 and 2pi using the trapezoidal rule:\" print '(F6.3)' , Int Int = quad ( f , a , b , h , 'Simpson' ) print * , \"Integral of sin(x) between 0 and 2pi using Simpson's rule:\" print '(F6.3)' , Int a = 0. b = 1. h = 0.001 Int = quad ( g , a , b , h , 'Trapezoidal' ) print * , \"Integral of x&#94;4 between 0 and 1 using the trapezoidal rule:\" print '(F6.3)' , Int Int = quad ( g , a , b , h , 'Simpson' ) print * , \"Integral of x&#94;4 between 0 and 1 using Simpson's rule:\" print '(F6.3)' , Int Int = quad ( g , 0. , 1. , h , 'Muller' ) contains function f ( x ) result ( y ) real , intent ( in ) :: x real :: y y = sin ( x ) end function function g ( x ) result ( y ) real , intent ( in ) :: x real :: y y = x ** 4 end function end program","tags":"","loc":"sourcefile/test_integrals.f08.html"},{"title":"integrals.f08 – Numerical Methods","text":"Files dependent on this one sourcefile~~integrals.f08~~AfferentGraph sourcefile~integrals.f08 integrals.f08 sourcefile~test_integrals.f08 test_integrals.f08 sourcefile~test_integrals.f08->sourcefile~integrals.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules integrals Source Code integrals.f08 Source Code module integrals !! module for computing integrals implicit none contains function trapz ( x , y ) result ( Int ) !! Aproximates the integral of the function !!  y = f(x) !! given a set of points: !! (x_i,y_i) !! using the trapezoidal rule. !! The points do not need to be linearly spaced along the !! integration domain. real , intent ( in ) :: x ( 0 :) !! Array containing the abscissas of the points real , intent ( in ) :: y ( 0 :) !! Array containing the ordinates of the points real :: Int !! Numerical aproximation to the integral integer :: i , N N = ubound ( x , 1 ) Int = 0. do i = 1 , N Int = Int + ( y ( i - 1 ) + y ( i )) / 2 * ( x ( i ) - x ( i - 1 )) end do end function function quad_trapz ( f , a , b , h_in ) result ( Int ) !! Approximates the integral: !!  \\int_{a}&#94;{b}f\\left(x\\right)\\,\\mathrm{d}x !! using the trapezoidal rule on a linearly spaced !! set of points. interface function f ( x ) result ( y ) !! Function to be integrated real , intent ( in ) :: x !! independent variable real :: y !! dependent variable end function end interface real , intent ( in ) :: a !! Lower limit of integration real , intent ( in ) :: b !! Upper limit of integration real , intent ( in ) :: h_in !! Approximated size of the intervals used by the trapezoidal rule. real :: Int !! Numerical approximation to the integral integer :: i , N real :: h , x_l , x_r ! imposing that h must divide (b-a) in a whole number ! of intervals N = ceiling (( b - a ) / h_in ) h = ( b - a ) / N Int = 0. do i = 1 , N x_l = ( i - 1 ) * h x_r = i * h Int = Int + ( f ( x_l ) + f ( x_r )) / 2 end do Int = Int * h end function function quad_simpson ( f , a , b , h_in ) result ( Int ) !! Approximates the integral: !!  \\int_{a}&#94;{b}f\\left(x\\right)\\,\\mathrm{d}x !! using Simpson's rule on a linearly spaced !! set of points. interface function f ( x ) result ( y ) !! Function to be integrated real , intent ( in ) :: x !! independent variable real :: y !! dependent variable end function end interface real , intent ( in ) :: a !! Lower limit of integration real , intent ( in ) :: b !! Upper limit of integration real , intent ( in ) :: h_in !! Approximated size of the intervals used by the trapezoidal rule. real :: Int !! Numerical approximation to the integral integer :: i , N real :: h , x_l , x_m , x_r ! imposing that h must divide (b-a) in an even number ! of intervals N = ceiling (( b - a ) / h_in ) if ( modulo ( N , 2 ) == 1 ) N = N + 1 h = ( b - a ) / N Int = 0. do i = 1 , N , 2 x_l = ( i - 1 ) * h x_m = i * h x_r = ( i + 1 ) * h Int = Int + ( f ( x_l ) + 4 * f ( x_m ) + f ( x_r )) / 3 end do Int = Int * h end function function quad ( f , a , b , h_in , method ) result ( Int ) !! Approximates the integral: !!  \\int_{a}&#94;{b}f\\left(x\\right)\\,\\mathrm{d}x !! using some integration method on a linearly spaced !! set of points. interface function f ( x ) result ( y ) !! Function to be integrated real , intent ( in ) :: x !! independent variable real :: y !! dependent variable end function end interface real , intent ( in ) :: a !! Lower limit of integration real , intent ( in ) :: b !! Upper limit of integration real , intent ( in ) :: h_in !! Approximated size of the intervals used by the trapezoidal rule. character ( * ) :: method !! Method of integration to be used, can be either \"Trapezoidal\" or \"Simpson\" real :: Int !! Numerical approximation to the integral select case ( method ) case ( \"Trapezoidal\" ) Int = quad_trapz ( f , a , b , h_in ) case ( \"Simpson\" ) Int = quad_simpson ( f , a , b , h_in ) case default print * , 'Integration method \"' // method // '\"\" not recognised,' print * , 'please choose between \"Trapezoidal\" and \"Simpson\"' end select end function end module","tags":"","loc":"sourcefile/integrals.f08.html"},{"title":"ode.f08 – Numerical Methods","text":"Files dependent on this one sourcefile~~ode.f08~~AfferentGraph sourcefile~ode.f08 ode.f08 sourcefile~test_ode.f08 test_ode.f08 sourcefile~test_ode.f08->sourcefile~ode.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules ode Source Code ode.f08 Source Code module ode !! Module for solving first order explicit ordinari differential equations, expressed in the form: !!  !! \\frac{dy}{dt}=F\\left(y,t\\right)\\\\ !! y(0) = y_0 !!  !! where, y(t) is the unknown function, t is the independent variable and !! y_0 is the initial condition. implicit none contains function forward_euler ( f , t , y0 ) result ( y ) !! function for integrating vector first order ODEs of the form: !!  !! \\frac{dy}{dt}=F\\left(y,t\\right) !!  !! using the forward (explicit) euler method. interface function f ( y , t ) result ( dy ) !! function defining the derivative of y for each !! time t and each value y real , intent ( in ) :: y (:) !! value of the unknown function y(t) real , intent ( in ) :: t !! independent variable t real :: dy ( size ( y )) !! derivative of y end function end interface real , intent ( in ) :: t ( 0 :) !! array of times  t_0,t_1,\\dots,t_N where the numerical solution !! will be evaluated. real , intent ( in ) :: y0 (:) !! initial conditions y(t_0) real :: y ( 0 : ubound ( t , 1 ), size ( y0 )) !! solution array y_j(t_i) such that the !! the row i and column j stands for the !! jth component of the vector solution at time t_i. integer :: N , i N = ubound ( t , 1 ) y ( 0 ,:) = y0 do i = 1 , N y ( i ,:) = y ( i - 1 ,:) + ( t ( i ) - t ( i - 1 )) * F ( y ( i - 1 ,:), t ( i - 1 )) end do end function end module","tags":"","loc":"sourcefile/ode.f08.html"},{"title":"eigen.f08 – Numerical Methods","text":"This file depends on sourcefile~~eigen.f08~~EfferentGraph sourcefile~eigen.f08 eigen.f08 sourcefile~linear_solvers.f08 linear_solvers.f08 sourcefile~eigen.f08->sourcefile~linear_solvers.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~eigen.f08~~AfferentGraph sourcefile~eigen.f08 eigen.f08 sourcefile~test_eigen.f08 test_eigen.f08 sourcefile~test_eigen.f08->sourcefile~eigen.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules eigenvectors Source Code eigen.f08 Source Code module eigenvectors !! Module for computing eigenvectors and their associated eigenvalues use linear_solvers , only : factor_LU , solve_LU implicit none contains subroutine eigen_max ( A , v , lambda , maxIter , err_v , v_0 ) !! Given the matrix **A**, computes the eigenvector **v** associated to !! the eivenvalue of maximum modulus **lambda**  using the power method. real , intent ( in ) :: A (:,:) !! Symmetric matrix real , intent ( out ) :: v ( size ( A , 1 )) !! Eigenvector real , intent ( out ) :: lambda !! Eigenvalue real , intent ( in ) :: err_v !! Precision for the stop criterion integer , intent ( in ) :: maxIter !! Maximum number of iterations real , intent ( in ) :: v_0 ( size ( A , 1 )) !! Initial vector for the iteration integer :: i real :: u ( size ( A , 1 )) u = v_0 u = u / norm2 ( u ) do i = 1 , maxIter v = matmul ( A , u ) lambda = dot_product ( u , v ) / dot_product ( u , u ) v = v / norm2 ( v ) if ( dot_product ( u , v ) > 0 ) then if ( norm2 ( u - v ) < err_v ) exit elseif ( dot_product ( u , v ) < 0 ) then if ( norm2 ( u + v ) < err_v ) exit end if u = v end do if ( i > maxIter ) print * , 'the maximum number of iteration was reached & & without obtaining convergence' end subroutine subroutine eigen_inv ( A , v , lambda , p , maxIter , err_v , v_0 ) !! Given the matrix **A**, computes the eigenvector **v** associated to the eivenvalue !! **lambda** closer to the value **p** using the inverse power method. real , intent ( in ) :: A (:,:) !! Symmetric matrix real , intent ( out ) :: v ( size ( A , 1 )) !! Eigenvector real , intent ( out ) :: lambda !! Eigenvalue real , intent ( in ) :: err_v !! Precision for the stop criterion integer , intent ( in ) :: maxIter !! Maximum number of iterations real , intent ( in ) :: v_0 ( size ( A , 1 )) !! Initial vector for the iteration real , intent ( in ) :: p !! value close to the eigenvalue wanted integer :: i real :: u ( size ( A , 1 )), D ( size ( A , 1 ), size ( A , 1 )) real :: Lo ( size ( A , 1 ), size ( A , 1 )), Up ( size ( A , 1 ), size ( A , 1 )) u = v_0 u = u / norm2 ( u ) D = 0 do i = 1 , size ( A , 1 ) D ( i , i ) = p end do call factor_LU ( A - D , Lo , Up ) do i = 1 , maxIter v = solve_LU ( Lo , Up , u ) lambda = dot_product ( u , v ) v = v / norm2 ( v ) lambda = 1. / lambda + p if ( dot_product ( u , v ) > 0 ) then if ( norm2 ( v - u ) < err_v ) exit elseif ( dot_product ( u , v ) < 0 ) then if ( norm2 ( v + u ) < err_v ) exit end if u = v end do if ( i > maxIter ) print * , 'the maximum number of iteration was reached & & without obtaining convergence' end subroutine end module","tags":"","loc":"sourcefile/eigen.f08.html"},{"title":"test_ode.f08 – Numerical Methods","text":"This file depends on sourcefile~~test_ode.f08~~EfferentGraph sourcefile~test_ode.f08 test_ode.f08 sourcefile~ode.f08 ode.f08 sourcefile~test_ode.f08->sourcefile~ode.f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs test_ode Source Code test_ode.f08 Source Code program test_ode !! program to test the ode module. !! The [Lorenz chaotic system](https://en.wikipedia.org/wiki/Lorenz_system) is solved: !!  !! \\frac{dx}{dt}=\\\\ !! \\frac{dx}{dt}=\\\\ !! \\frac{dx}{dt}= !!  use ode implicit none integer , parameter :: N = 1000 ; real :: Tf , dT real :: t ( 0 : N ), y ( 0 : N , 3 ) integer :: i , u Tf = 10 dT = Tf / N do i = 0 , N t ( i ) = i * dT end do y = forward_euler ( lorenz , t , [ 1. , 1. , 1. ]) open ( file = 'datos.dat' , newunit = u ) do i = 0 , N write ( u , * ) t ( i ), y ( i , 1 ), y ( i , 2 ), y ( i , 3 ) end do close ( u ) contains function lorenz ( y , t ) result ( dy ) !! function for defining the [Lorenz system](https://en.wikipedia.org/wiki/Lorenz_system) real , intent ( in ) :: y (:) real , intent ( in ) :: t real :: dy ( size ( y )) real , parameter :: a = 1 0. real , parameter :: b = 2 8. real , parameter :: c = 8. / 3. dy ( 1 ) = a * ( y ( 2 ) - y ( 1 )) dy ( 2 ) = y ( 1 ) * ( b - y ( 3 )) - y ( 2 ) dy ( 3 ) = y ( 1 ) * y ( 2 ) - c * y ( 3 ) end function end program","tags":"","loc":"sourcefile/test_ode.f08.html"},{"title":"f – Numerical Methods","text":"function f(x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/f.html"},{"title":"df – Numerical Methods","text":"function df(x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/df.html"},{"title":"f_vec – Numerical Methods","text":"function f_vec(x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) Return Value real\n  (size(x)) Contents None","tags":"","loc":"proc/f_vec.html"},{"title":"J – Numerical Methods","text":"function J(x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) Return Value real\n  (size(x),size(x)) Contents None","tags":"","loc":"proc/j.html"},{"title":"solve_U – Numerical Methods","text":"public function solve_U(U, b) result(x) Computes the solution of an upper triangular system: Arguments Type Intent Optional Attributes Name real, intent(in) :: U (:,:) Upper triangular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(U,2)) Solution vector x Called by proc~~solve_u~~CalledByGraph proc~solve_u solve_U proc~gauss_solve gauss_solve proc~gauss_solve->proc~solve_u proc~solve_lu solve_LU proc~solve_lu->proc~solve_u proc~solve solve proc~solve->proc~solve_lu program~test test program~test->proc~gauss_solve program~test->proc~solve proc~eigen_inv eigen_inv proc~eigen_inv->proc~solve_lu proc~vectornewton VectorNewton proc~vectornewton->proc~solve program~test_eigenvectors test_eigenvectors program~test_eigenvectors->proc~eigen_inv program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~vectornewton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_u.html"},{"title":"solve_L – Numerical Methods","text":"public function solve_L(L, b) result(x) Computes the solution of a lower triangular system: Arguments Type Intent Optional Attributes Name real, intent(in) :: L (:,:) Lower triangular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(L,2)) Solution vector x Called by proc~~solve_l~~CalledByGraph proc~solve_l solve_L proc~gaussseidel GaussSeidel proc~gaussseidel->proc~solve_l proc~solve_lu solve_LU proc~solve_lu->proc~solve_l proc~solve solve proc~solve->proc~solve_lu program~test test program~test->proc~gaussseidel program~test->proc~solve proc~eigen_inv eigen_inv proc~eigen_inv->proc~solve_lu proc~vectornewton VectorNewton proc~vectornewton->proc~solve program~test_eigenvectors test_eigenvectors program~test_eigenvectors->proc~eigen_inv program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~vectornewton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_l.html"},{"title":"gauss_solve – Numerical Methods","text":"public function gauss_solve(A, b) result(x) Computes the solution of the system: where A is a non-singular matrix. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(A,2)) Solution vector x Calls proc~~gauss_solve~~CallsGraph proc~gauss_solve gauss_solve proc~make_u make_U proc~gauss_solve->proc~make_u proc~solve_u solve_U proc~gauss_solve->proc~solve_u Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gauss_solve~~CalledByGraph proc~gauss_solve gauss_solve program~test test program~test->proc~gauss_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gauss_solve.html"},{"title":"solve_LU – Numerical Methods","text":"public function solve_LU(L, U, b) result(x) Computes the solution to the system: where L and U are the matrices obtained from\n a LU factorization. Arguments Type Intent Optional Attributes Name real, intent(in) :: L (:,:) Lower triangular matrix real, intent(in) :: U (:,:) Upper triangular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(b)) Solution vector x Calls proc~~solve_lu~~CallsGraph proc~solve_lu solve_LU proc~solve_u solve_U proc~solve_lu->proc~solve_u proc~solve_l solve_L proc~solve_lu->proc~solve_l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~solve_lu~~CalledByGraph proc~solve_lu solve_LU proc~solve solve proc~solve->proc~solve_lu proc~eigen_inv eigen_inv proc~eigen_inv->proc~solve_lu program~test test program~test->proc~solve proc~vectornewton VectorNewton proc~vectornewton->proc~solve program~test_eigenvectors test_eigenvectors program~test_eigenvectors->proc~eigen_inv program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~vectornewton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve_lu.html"},{"title":"solve – Numerical Methods","text":"public function solve(A, b) result(x) Computes the solution to the system: using LU factorization. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(b)) Solution vector x Calls proc~~solve~~CallsGraph proc~solve solve proc~factor_lu factor_LU proc~solve->proc~factor_lu proc~solve_lu solve_LU proc~solve->proc~solve_lu proc~solve_u solve_U proc~solve_lu->proc~solve_u proc~solve_l solve_L proc~solve_lu->proc~solve_l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~solve~~CalledByGraph proc~solve solve program~test test program~test->proc~solve proc~vectornewton VectorNewton proc~vectornewton->proc~solve program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~vectornewton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/solve.html"},{"title":"Jacobi – Numerical Methods","text":"public function Jacobi(A, b, x_0, maxIter, err_x) result(x) Computes the solution to the system using the Jacobi iterative method. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(in) :: b (:) Right hand side vector real, intent(in) :: x_0 (:) Initial approximation for the iteration integer, intent(in) :: maxIter Maximum number of iterations real, intent(in) :: err_x Precision for the stop criterion Return Value real\n  (size(A,2)) Solution vector x Called by proc~~jacobi~~CalledByGraph proc~jacobi Jacobi program~test test program~test->proc~jacobi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/jacobi.html"},{"title":"GaussSeidel – Numerical Methods","text":"public function GaussSeidel(A, b, x_0, maxIter, err_x) result(x) Computes the solution to the system using the Gauss-Seidel iterative method. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(in) :: b (:) Right hand side vector real, intent(in) :: x_0 (:) Initial approximation for the iteration integer, intent(in) :: maxIter Maximum number of iterations real, intent(in) :: err_x Precision for the stop criterion Return Value real\n  (size(A,2)) Solution vector x Calls proc~~gaussseidel~~CallsGraph proc~gaussseidel GaussSeidel proc~solve_l solve_L proc~gaussseidel->proc~solve_l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~gaussseidel~~CalledByGraph proc~gaussseidel GaussSeidel program~test test program~test->proc~gaussseidel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/gaussseidel.html"},{"title":"make_U – Numerical Methods","text":"public subroutine make_U(M) Takes the extended matrix M = (A|b)\n and makes it upper triangular. Arguments Type Intent Optional Attributes Name real, intent(inout) :: M (:,:) Extended matrix (A|b) Called by proc~~make_u~~CalledByGraph proc~make_u make_U proc~gauss_solve gauss_solve proc~gauss_solve->proc~make_u program~test test program~test->proc~gauss_solve Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/make_u.html"},{"title":"factor_LU – Numerical Methods","text":"public subroutine factor_LU(A, L, U) Computes de LU factorization of a non-singular matrix A Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(out) :: L (size(A,1),size(A,2)) Lower triangular matrix real, intent(out) :: U (size(A,1),size(A,2)) Upper triangular matrix Called by proc~~factor_lu~~CalledByGraph proc~factor_lu factor_LU proc~solve solve proc~solve->proc~factor_lu proc~eigen_inv eigen_inv proc~eigen_inv->proc~factor_lu program~test test program~test->proc~solve proc~vectornewton VectorNewton proc~vectornewton->proc~solve program~test_eigenvectors test_eigenvectors program~test_eigenvectors->proc~eigen_inv program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~vectornewton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/factor_lu.html"},{"title":"Bisection – Numerical Methods","text":"public function Bisection(f, a, b, err_x) result(x) Solves the scalar non-linear equation: using the bisection method on the interval Arguments Type Intent Optional Attributes Name public function f(x) result(y) function defining the non-linear equation Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: a left boundary of the interval real, intent(in) :: b right boundary of the interval real, intent(in) :: err_x admisible error in the solution, that is: Return Value real numerical aproximation to the solution Called by proc~~bisection~~CalledByGraph proc~bisection Bisection program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~bisection Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/bisection.html"},{"title":"Newton – Numerical Methods","text":"public function Newton(f, df, x0, err_x, err_f, max_iter) result(x) Solves the scalar non-linear equation: using Newton's method. Arguments Type Intent Optional Attributes Name public function f(x) result(y) function defining the non-linear equation Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable public function df(x) result(y) derivative of function Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: x0 initial aproximation to the solution real, intent(in) :: err_x admisible error in the solution real, intent(in) :: err_f admisible error in the equation integer, intent(in) :: max_iter maximum number of iterations Return Value real numerical aproximation to the solution Called by proc~~newton~~CalledByGraph proc~newton Newton program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~newton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/newton.html"},{"title":"Secant – Numerical Methods","text":"public function Secant(f, x0, err_x, err_f, max_iter) result(x) Solves the scalar non-linear equation: using the secant method. Arguments Type Intent Optional Attributes Name public function f(x) result(y) function defining the non-linear equation Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: x0 (2) array containing the first and second aproximations to the solution real, intent(in) :: err_x admisible error in the solution real, intent(in) :: err_f admisible error in the equation integer, intent(in) :: max_iter maximum number of iterations Return Value real numerical aproximation to the solution Called by proc~~secant~~CalledByGraph proc~secant Secant program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~secant Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/secant.html"},{"title":"VectorNewton – Numerical Methods","text":"public function VectorNewton(f, J, x0, err_x, err_f, max_iter) result(x) Solves the vector non-linear equation: using Newton's method. Arguments Type Intent Optional Attributes Name public function f(x) result(y) function defining the non-linear equation Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) independent variable Return Value real\n  (size(x)) dependent variable public function J(x) result(y) jacobian of function Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) independent variable Return Value real\n  (size(x),size(x)) dependent variable real, intent(in) :: x0 (:) initial aproximation to the solution: real, intent(in) :: err_x admisible error in the solution real, intent(in) :: err_f admisible error in the equation integer, intent(in) :: max_iter maximum number of iterations Return Value real\n  (size(x0)) numerical aproximation to the solution Calls proc~~vectornewton~~CallsGraph proc~vectornewton VectorNewton proc~solve solve proc~vectornewton->proc~solve proc~factor_lu factor_LU proc~solve->proc~factor_lu proc~solve_lu solve_LU proc~solve->proc~solve_lu proc~solve_u solve_U proc~solve_lu->proc~solve_u proc~solve_l solve_L proc~solve_lu->proc~solve_l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~vectornewton~~CalledByGraph proc~vectornewton VectorNewton program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->proc~vectornewton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/vectornewton.html"},{"title":"print_matrix – Numerical Methods","text":"public subroutine print_matrix(A) Prints a real matrix in a tabular form\n (can be improved) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) matriz to be displayed Called by proc~~print_matrix~~CalledByGraph proc~print_matrix print_matrix program~test_utilities test_utilities program~test_utilities->proc~print_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_matrix.html"},{"title":"to_csv – Numerical Methods","text":"public subroutine to_csv(D, filename) saves two-dimensional array D to csv\n file filename Arguments Type Intent Optional Attributes Name real, intent(in) :: D (:,:) array to be saved character(len=*), intent(in) :: filename path to the csv file Contents None","tags":"","loc":"proc/to_csv.html"},{"title":"read_2_columns_csv – Numerical Methods","text":"public subroutine read_2_columns_csv(filename, D) Reads a two-column csv from file filename and stores it in D Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename path to the file real, intent(inout), allocatable :: D (:,:) array containing the two columns read Contents None","tags":"","loc":"proc/read_2_columns_csv.html"},{"title":"f – Numerical Methods","text":"function f(x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/f~2.html"},{"title":"g – Numerical Methods","text":"function g(x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real Contents None","tags":"","loc":"proc/g.html"},{"title":"trapz – Numerical Methods","text":"public function trapz(x, y) result(Int) Aproximates the integral of the function given a set of points: using the trapezoidal rule.\n The points do not need to be linearly spaced along the\n integration domain. Arguments Type Intent Optional Attributes Name real, intent(in) :: x (0:) Array containing the abscissas of the points real, intent(in) :: y (0:) Array containing the ordinates of the points Return Value real Numerical aproximation to the integral Contents None","tags":"","loc":"proc/trapz.html"},{"title":"quad_trapz – Numerical Methods","text":"public function quad_trapz(f, a, b, h_in) result(Int) Approximates the integral: using the trapezoidal rule on a linearly spaced\n set of points. Arguments Type Intent Optional Attributes Name public function f(x) result(y) Function to be integrated Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: a Lower limit of integration real, intent(in) :: b Upper limit of integration real, intent(in) :: h_in Approximated size of the intervals used by the trapezoidal rule. Return Value real Numerical approximation to the integral Called by proc~~quad_trapz~~CalledByGraph proc~quad_trapz quad_trapz proc~quad quad proc~quad->proc~quad_trapz program~test_integrals test_integrals program~test_integrals->proc~quad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/quad_trapz.html"},{"title":"quad_simpson – Numerical Methods","text":"public function quad_simpson(f, a, b, h_in) result(Int) Approximates the integral: using Simpson's rule on a linearly spaced\n set of points. Arguments Type Intent Optional Attributes Name public function f(x) result(y) Function to be integrated Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: a Lower limit of integration real, intent(in) :: b Upper limit of integration real, intent(in) :: h_in Approximated size of the intervals used by the trapezoidal rule. Return Value real Numerical approximation to the integral Called by proc~~quad_simpson~~CalledByGraph proc~quad_simpson quad_simpson proc~quad quad proc~quad->proc~quad_simpson program~test_integrals test_integrals program~test_integrals->proc~quad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/quad_simpson.html"},{"title":"quad – Numerical Methods","text":"public function quad(f, a, b, h_in, method) result(Int) Approximates the integral: using some integration method on a linearly spaced\n set of points. Arguments Type Intent Optional Attributes Name public function f(x) result(y) Function to be integrated Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: a Lower limit of integration real, intent(in) :: b Upper limit of integration real, intent(in) :: h_in Approximated size of the intervals used by the trapezoidal rule. character(len=*) :: method Method of integration to be used, can be either \"Trapezoidal\" or \"Simpson\" Return Value real Numerical approximation to the integral Calls proc~~quad~~CallsGraph proc~quad quad proc~quad_simpson quad_simpson proc~quad->proc~quad_simpson proc~quad_trapz quad_trapz proc~quad->proc~quad_trapz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~quad~~CalledByGraph proc~quad quad program~test_integrals test_integrals program~test_integrals->proc~quad Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/quad.html"},{"title":"forward_euler – Numerical Methods","text":"public function forward_euler(f, t, y0) result(y) function for integrating vector first order ODEs of the form: using the forward (explicit) euler method. Arguments Type Intent Optional Attributes Name public function f(y, t) result(dy) function defining the derivative of for each\n time and each value Arguments Type Intent Optional Attributes Name real, intent(in) :: y (:) value of the unknown function real, intent(in) :: t independent variable Return Value real\n  (size(y)) derivative of real, intent(in) :: t (0:) array of times where the numerical solution\n will be evaluated. real, intent(in) :: y0 (:) initial conditions Return Value real\n  (0:ubound(t,1),size(y0)) solution array such that the\n the row and column stands for the th component of the vector solution at time . Called by proc~~forward_euler~~CalledByGraph proc~forward_euler forward_euler program~test_ode test_ode program~test_ode->proc~forward_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/forward_euler.html"},{"title":"eigen_max – Numerical Methods","text":"public subroutine eigen_max(A, v, lambda, maxIter, err_v, v_0) Given the matrix A , computes the eigenvector v associated to\n the eivenvalue of maximum modulus lambda using the power method. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Symmetric matrix real, intent(out) :: v (size(A,1)) Eigenvector real, intent(out) :: lambda Eigenvalue integer, intent(in) :: maxIter Maximum number of iterations real, intent(in) :: err_v Precision for the stop criterion real, intent(in) :: v_0 (size(A,1)) Initial vector for the iteration Called by proc~~eigen_max~~CalledByGraph proc~eigen_max eigen_max program~test_eigenvectors test_eigenvectors program~test_eigenvectors->proc~eigen_max Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eigen_max.html"},{"title":"eigen_inv – Numerical Methods","text":"public subroutine eigen_inv(A, v, lambda, p, maxIter, err_v, v_0) Given the matrix A , computes the eigenvector v associated to the eivenvalue lambda closer to the value p using the inverse power method. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Symmetric matrix real, intent(out) :: v (size(A,1)) Eigenvector real, intent(out) :: lambda Eigenvalue real, intent(in) :: p value close to the eigenvalue wanted integer, intent(in) :: maxIter Maximum number of iterations real, intent(in) :: err_v Precision for the stop criterion real, intent(in) :: v_0 (size(A,1)) Initial vector for the iteration Calls proc~~eigen_inv~~CallsGraph proc~eigen_inv eigen_inv proc~factor_lu factor_LU proc~eigen_inv->proc~factor_lu proc~solve_lu solve_LU proc~eigen_inv->proc~solve_lu proc~solve_u solve_U proc~solve_lu->proc~solve_u proc~solve_l solve_L proc~solve_lu->proc~solve_l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~eigen_inv~~CalledByGraph proc~eigen_inv eigen_inv program~test_eigenvectors test_eigenvectors program~test_eigenvectors->proc~eigen_inv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/eigen_inv.html"},{"title":"lorenz – Numerical Methods","text":"function lorenz(y, t) result(dy) function for defining the Lorenz system Arguments Type Intent Optional Attributes Name real, intent(in) :: y (:) real, intent(in) :: t Return Value real\n  (size(y)) Contents None","tags":"","loc":"proc/lorenz.html"},{"title":"linear_solvers – Numerical Methods","text":"Module for computing solutions to linear systems of the form: Used by module~~linear_solvers~~UsedByGraph module~linear_solvers linear_solvers module~non_linear_solvers non_linear_solvers module~non_linear_solvers->module~linear_solvers program~test test program~test->module~linear_solvers module~eigenvectors eigenvectors module~eigenvectors->module~linear_solvers program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->module~non_linear_solvers program~test_eigenvectors test_eigenvectors program~test_eigenvectors->module~eigenvectors Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions solve_U solve_L gauss_solve solve_LU solve Jacobi GaussSeidel Subroutines make_U factor_LU Functions public function solve_U (U, b) result(x) Computes the solution of an upper triangular system: Arguments Type Intent Optional Attributes Name real, intent(in) :: U (:,:) Upper triangular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(U,2)) Solution vector x public function solve_L (L, b) result(x) Computes the solution of a lower triangular system: Arguments Type Intent Optional Attributes Name real, intent(in) :: L (:,:) Lower triangular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(L,2)) Solution vector x public function gauss_solve (A, b) result(x) Computes the solution of the system: where A is a non-singular matrix. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(A,2)) Solution vector x public function solve_LU (L, U, b) result(x) Computes the solution to the system: where L and U are the matrices obtained from\n a LU factorization. Arguments Type Intent Optional Attributes Name real, intent(in) :: L (:,:) Lower triangular matrix real, intent(in) :: U (:,:) Upper triangular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(b)) Solution vector x public function solve (A, b) result(x) Computes the solution to the system: using LU factorization. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(in) :: b (:) Right hand side vector Return Value real\n  (size(b)) Solution vector x public function Jacobi (A, b, x_0, maxIter, err_x) result(x) Computes the solution to the system using the Jacobi iterative method. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(in) :: b (:) Right hand side vector real, intent(in) :: x_0 (:) Initial approximation for the iteration integer, intent(in) :: maxIter Maximum number of iterations real, intent(in) :: err_x Precision for the stop criterion Return Value real\n  (size(A,2)) Solution vector x public function GaussSeidel (A, b, x_0, maxIter, err_x) result(x) Computes the solution to the system using the Gauss-Seidel iterative method. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(in) :: b (:) Right hand side vector real, intent(in) :: x_0 (:) Initial approximation for the iteration integer, intent(in) :: maxIter Maximum number of iterations real, intent(in) :: err_x Precision for the stop criterion Return Value real\n  (size(A,2)) Solution vector x Subroutines public subroutine make_U (M) Takes the extended matrix M = (A|b)\n and makes it upper triangular. Arguments Type Intent Optional Attributes Name real, intent(inout) :: M (:,:) Extended matrix (A|b) public subroutine factor_LU (A, L, U) Computes de LU factorization of a non-singular matrix A Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Non-singular matrix real, intent(out) :: L (size(A,1),size(A,2)) Lower triangular matrix real, intent(out) :: U (size(A,1),size(A,2)) Upper triangular matrix","tags":"","loc":"module/linear_solvers.html"},{"title":"non_linear_solvers – Numerical Methods","text":"Module for solving non-linear equations of the form: There are specific functions for the scalar case. Uses linear_solvers module~~non_linear_solvers~~UsesGraph module~non_linear_solvers non_linear_solvers module~linear_solvers linear_solvers module~non_linear_solvers->module~linear_solvers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~non_linear_solvers~~UsedByGraph module~non_linear_solvers non_linear_solvers program~test_non_linear_solvers test_non_linear_solvers program~test_non_linear_solvers->module~non_linear_solvers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions Bisection Newton Secant VectorNewton Functions public function Bisection (f, a, b, err_x) result(x) Solves the scalar non-linear equation: using the bisection method on the interval Arguments Type Intent Optional Attributes Name public function f(x) result(y) function defining the non-linear equation Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: a left boundary of the interval real, intent(in) :: b right boundary of the interval real, intent(in) :: err_x admisible error in the solution, that is: Return Value real numerical aproximation to the solution public function Newton (f, df, x0, err_x, err_f, max_iter) result(x) Solves the scalar non-linear equation: using Newton's method. Arguments Type Intent Optional Attributes Name public function f(x) result(y) function defining the non-linear equation Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable public function df(x) result(y) derivative of function Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: x0 initial aproximation to the solution real, intent(in) :: err_x admisible error in the solution real, intent(in) :: err_f admisible error in the equation integer, intent(in) :: max_iter maximum number of iterations Return Value real numerical aproximation to the solution public function Secant (f, x0, err_x, err_f, max_iter) result(x) Solves the scalar non-linear equation: using the secant method. Arguments Type Intent Optional Attributes Name public function f(x) result(y) function defining the non-linear equation Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: x0 (2) array containing the first and second aproximations to the solution real, intent(in) :: err_x admisible error in the solution real, intent(in) :: err_f admisible error in the equation integer, intent(in) :: max_iter maximum number of iterations Return Value real numerical aproximation to the solution public function VectorNewton (f, J, x0, err_x, err_f, max_iter) result(x) Solves the vector non-linear equation: using Newton's method. Arguments Type Intent Optional Attributes Name public function f(x) result(y) function defining the non-linear equation Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) independent variable Return Value real\n  (size(x)) dependent variable public function J(x) result(y) jacobian of function Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) independent variable Return Value real\n  (size(x),size(x)) dependent variable real, intent(in) :: x0 (:) initial aproximation to the solution: real, intent(in) :: err_x admisible error in the solution real, intent(in) :: err_f admisible error in the equation integer, intent(in) :: max_iter maximum number of iterations Return Value real\n  (size(x0)) numerical aproximation to the solution","tags":"","loc":"module/non_linear_solvers.html"},{"title":"utilities – Numerical Methods","text":"module with utilities like printing a matrix, or some constants Used by module~~utilities~~UsedByGraph module~utilities utilities program~test_utilities test_utilities program~test_utilities->module~utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pi e Subroutines print_matrix to_csv read_2_columns_csv Variables Type Visibility Attributes Name Initial real, public :: pi = acos(-1.) mathematical constant pi real, public :: e = exp(1.) mathematical constante e Subroutines public subroutine print_matrix (A) Prints a real matrix in a tabular form\n (can be improved) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) matriz to be displayed public subroutine to_csv (D, filename) saves two-dimensional array D to csv\n file filename Arguments Type Intent Optional Attributes Name real, intent(in) :: D (:,:) array to be saved character(len=*), intent(in) :: filename path to the csv file public subroutine read_2_columns_csv (filename, D) Reads a two-column csv from file filename and stores it in D Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename path to the file real, intent(inout), allocatable :: D (:,:) array containing the two columns read","tags":"","loc":"module/utilities.html"},{"title":"integrals – Numerical Methods","text":"module for computing integrals Used by module~~integrals~~UsedByGraph module~integrals integrals program~test_integrals test_integrals program~test_integrals->module~integrals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions trapz quad_trapz quad_simpson quad Functions public function trapz (x, y) result(Int) Aproximates the integral of the function given a set of points: using the trapezoidal rule.\n The points do not need to be linearly spaced along the\n integration domain. Arguments Type Intent Optional Attributes Name real, intent(in) :: x (0:) Array containing the abscissas of the points real, intent(in) :: y (0:) Array containing the ordinates of the points Return Value real Numerical aproximation to the integral public function quad_trapz (f, a, b, h_in) result(Int) Approximates the integral: using the trapezoidal rule on a linearly spaced\n set of points. Arguments Type Intent Optional Attributes Name public function f(x) result(y) Function to be integrated Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: a Lower limit of integration real, intent(in) :: b Upper limit of integration real, intent(in) :: h_in Approximated size of the intervals used by the trapezoidal rule. Return Value real Numerical approximation to the integral public function quad_simpson (f, a, b, h_in) result(Int) Approximates the integral: using Simpson's rule on a linearly spaced\n set of points. Arguments Type Intent Optional Attributes Name public function f(x) result(y) Function to be integrated Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: a Lower limit of integration real, intent(in) :: b Upper limit of integration real, intent(in) :: h_in Approximated size of the intervals used by the trapezoidal rule. Return Value real Numerical approximation to the integral public function quad (f, a, b, h_in, method) result(Int) Approximates the integral: using some integration method on a linearly spaced\n set of points. Arguments Type Intent Optional Attributes Name public function f(x) result(y) Function to be integrated Arguments Type Intent Optional Attributes Name real, intent(in) :: x independent variable Return Value real dependent variable real, intent(in) :: a Lower limit of integration real, intent(in) :: b Upper limit of integration real, intent(in) :: h_in Approximated size of the intervals used by the trapezoidal rule. character(len=*) :: method Method of integration to be used, can be either \"Trapezoidal\" or \"Simpson\" Return Value real Numerical approximation to the integral","tags":"","loc":"module/integrals.html"},{"title":"ode – Numerical Methods","text":"Module for solving first order explicit ordinari differential equations, expressed in the form: where, is the unknown function, is the independent variable and is the initial condition. Used by module~~ode~~UsedByGraph module~ode ode program~test_ode test_ode program~test_ode->module~ode Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions forward_euler Functions public function forward_euler (f, t, y0) result(y) function for integrating vector first order ODEs of the form: using the forward (explicit) euler method. Arguments Type Intent Optional Attributes Name public function f(y, t) result(dy) function defining the derivative of for each\n time and each value Arguments Type Intent Optional Attributes Name real, intent(in) :: y (:) value of the unknown function real, intent(in) :: t independent variable Return Value real\n  (size(y)) derivative of real, intent(in) :: t (0:) array of times where the numerical solution\n will be evaluated. real, intent(in) :: y0 (:) initial conditions Return Value real\n  (0:ubound(t,1),size(y0)) solution array such that the\n the row and column stands for the th component of the vector solution at time .","tags":"","loc":"module/ode.html"},{"title":"eigenvectors – Numerical Methods","text":"Module for computing eigenvectors and their associated eigenvalues Uses linear_solvers module~~eigenvectors~~UsesGraph module~eigenvectors eigenvectors module~linear_solvers linear_solvers module~eigenvectors->module~linear_solvers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~eigenvectors~~UsedByGraph module~eigenvectors eigenvectors program~test_eigenvectors test_eigenvectors program~test_eigenvectors->module~eigenvectors Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines eigen_max eigen_inv Subroutines public subroutine eigen_max (A, v, lambda, maxIter, err_v, v_0) Given the matrix A , computes the eigenvector v associated to\n the eivenvalue of maximum modulus lambda using the power method. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Symmetric matrix real, intent(out) :: v (size(A,1)) Eigenvector real, intent(out) :: lambda Eigenvalue integer, intent(in) :: maxIter Maximum number of iterations real, intent(in) :: err_v Precision for the stop criterion real, intent(in) :: v_0 (size(A,1)) Initial vector for the iteration public subroutine eigen_inv (A, v, lambda, p, maxIter, err_v, v_0) Given the matrix A , computes the eigenvector v associated to the eivenvalue lambda closer to the value p using the inverse power method. Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Symmetric matrix real, intent(out) :: v (size(A,1)) Eigenvector real, intent(out) :: lambda Eigenvalue real, intent(in) :: p value close to the eigenvalue wanted integer, intent(in) :: maxIter Maximum number of iterations real, intent(in) :: err_v Precision for the stop criterion real, intent(in) :: v_0 (size(A,1)) Initial vector for the iteration","tags":"","loc":"module/eigenvectors.html"},{"title":"test_utilities – Numerical Methods","text":"Uses utilities program~~test_utilities~~UsesGraph program~test_utilities test_utilities module~utilities utilities program~test_utilities->module~utilities Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test_utilities~~CallsGraph program~test_utilities test_utilities proc~print_matrix print_matrix program~test_utilities->proc~print_matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables M N A Variables Type Attributes Name Initial integer, parameter :: M = 3 integer, parameter :: N = 4 real :: A (M,N)","tags":"","loc":"program/test_utilities.html"},{"title":"test_non_linear_solvers – Numerical Methods","text":"Uses non_linear_solvers program~~test_non_linear_solvers~~UsesGraph program~test_non_linear_solvers test_non_linear_solvers module~non_linear_solvers non_linear_solvers program~test_non_linear_solvers->module~non_linear_solvers module~linear_solvers linear_solvers module~non_linear_solvers->module~linear_solvers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. program to test the non_linear_solvers module Calls program~~test_non_linear_solvers~~CallsGraph program~test_non_linear_solvers test_non_linear_solvers proc~secant Secant program~test_non_linear_solvers->proc~secant proc~bisection Bisection program~test_non_linear_solvers->proc~bisection proc~newton Newton program~test_non_linear_solvers->proc~newton proc~vectornewton VectorNewton program~test_non_linear_solvers->proc~vectornewton proc~solve solve proc~vectornewton->proc~solve proc~factor_lu factor_LU proc~solve->proc~factor_lu proc~solve_lu solve_LU proc~solve->proc~solve_lu proc~solve_u solve_U proc~solve_lu->proc~solve_u proc~solve_l solve_L proc~solve_lu->proc~solve_l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Functions f df f_vec J Functions function f (x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real function df (x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real function f_vec (x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) Return Value real\n  (size(x)) function J (x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x (:) Return Value real\n  (size(x),size(x))","tags":"","loc":"program/test_non_linear_solvers.html"},{"title":"test – Numerical Methods","text":"Uses linear_solvers program~~test~~UsesGraph program~test test module~linear_solvers linear_solvers program~test->module~linear_solvers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Program to show the usage of the linear_solvers module Calls program~~test~~CallsGraph program~test test proc~jacobi Jacobi program~test->proc~jacobi proc~gaussseidel GaussSeidel program~test->proc~gaussseidel proc~solve solve program~test->proc~solve proc~gauss_solve gauss_solve program~test->proc~gauss_solve proc~solve_l solve_L proc~gaussseidel->proc~solve_l proc~factor_lu factor_LU proc~solve->proc~factor_lu proc~solve_lu solve_LU proc~solve->proc~solve_lu proc~make_u make_U proc~gauss_solve->proc~make_u proc~solve_u solve_U proc~gauss_solve->proc~solve_u proc~solve_lu->proc~solve_l proc~solve_lu->proc~solve_u Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables N ti tf A b x_G x_LU x_J x_GS x_0 i u Nmax Variables Type Attributes Name Initial integer, parameter :: N = 500 real :: ti real :: tf real :: A (N,N) real :: b (N) real :: x_G (N) real :: x_LU (N) real :: x_J (N) real :: x_GS (N) real :: x_0 (N) integer :: i integer :: u integer :: Nmax","tags":"","loc":"program/test.html"},{"title":"test_eigenvectors – Numerical Methods","text":"Uses eigenvectors program~~test_eigenvectors~~UsesGraph program~test_eigenvectors test_eigenvectors module~eigenvectors eigenvectors program~test_eigenvectors->module~eigenvectors module~linear_solvers linear_solvers module~eigenvectors->module~linear_solvers Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Program to show the usage of the the eigenvectors module. Calls program~~test_eigenvectors~~CallsGraph program~test_eigenvectors test_eigenvectors proc~eigen_max eigen_max program~test_eigenvectors->proc~eigen_max proc~eigen_inv eigen_inv program~test_eigenvectors->proc~eigen_inv proc~factor_lu factor_LU proc~eigen_inv->proc~factor_lu proc~solve_lu solve_LU proc~eigen_inv->proc~solve_lu proc~solve_u solve_U proc~solve_lu->proc~solve_u proc~solve_l solve_L proc~solve_lu->proc~solve_l Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables N i A v lambda1 lambda2 lambda3 fmt Variables Type Attributes Name Initial integer, parameter :: N = 3 integer :: i real :: A (N,N) real :: v (N) real :: lambda1 real :: lambda2 real :: lambda3 character(len=:), allocatable :: fmt","tags":"","loc":"program/test_eigenvectors.html"},{"title":"test_integrals – Numerical Methods","text":"Uses integrals program~~test_integrals~~UsesGraph program~test_integrals test_integrals module~integrals integrals program~test_integrals->module~integrals Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. program to show the usage of the integrals module Calls program~~test_integrals~~CallsGraph program~test_integrals test_integrals proc~quad quad program~test_integrals->proc~quad proc~quad_simpson quad_simpson proc~quad->proc~quad_simpson proc~quad_trapz quad_trapz proc~quad->proc~quad_trapz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables pi a b h Int i Functions f g Variables Type Attributes Name Initial real, parameter :: pi = acos(-1.) real :: a real :: b real :: h real :: Int integer :: i Functions function f (x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real function g (x) result(y) Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value real","tags":"","loc":"program/test_integrals.html"},{"title":"test_ode – Numerical Methods","text":"Uses ode program~~test_ode~~UsesGraph program~test_ode test_ode module~ode ode program~test_ode->module~ode Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. program to test the ode module.\n The Lorenz chaotic system is solved: Calls program~~test_ode~~CallsGraph program~test_ode test_ode proc~forward_euler forward_euler program~test_ode->proc~forward_euler Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables N Tf dT t y i u Functions lorenz Variables Type Attributes Name Initial integer, parameter :: N = 1000 real :: Tf real :: dT real :: t (0:N) real :: y (0:N,3) integer :: i integer :: u Functions function lorenz (y, t) result(dy) function for defining the Lorenz system Arguments Type Intent Optional Attributes Name real, intent(in) :: y (:) real, intent(in) :: t Return Value real\n  (size(y))","tags":"","loc":"program/test_ode.html"}]}